\section{Определения}

Перед тем, как приступать к непосредственному описанию результатов,
введём некоторые неформальные определения, которыми будем в дальнейшем
руководствоваваться. 

\begin{definition}[Ревизия]
  Назовём \emph{ревизией} состояние, которое может быть сохранено в
  системе контроля версий. Фактически, это просто будет некоторое
  состояние какой-то структуры данных.
\end{definition}

Напрмер, \emph{ревизией} в git-репозитории является список файлов и их
содержимое. О том, какие будут рассмотрены примеры ревизий, будет
сказано позже.

\begin{definition}[Патч]
  \emph{Патч}~--- нечто, описывающее преобразование одной ревизии в
  другую.
\end{definition}

Например, если ревизия~--- обычный текстовый файл, то в качестве
патча, преобразующего файл \texttt{a.txt} в файл \texttt{b.txt} можно
взять выдачу утилиты UNIX diff: \texttt{diff a.txt b.txt}. 

\begin{definition}[Система контроля версий (VCS)]
  В рамках данной работы \emph{системой контроля версий} будем
  называть некую структуру, хранящую ревизии и патчи вместе с
  интерфейсом доступа к ней.
\end{definition}

В это определение вписываются все рассмотренные выше системы контроля
версий. 

Будем реализовывать на языке программирования Agda \emph{систему
  контроля версий}, поддерживающую следующие операции:
\begin{itemize}
\item неконфликтующее объединение патчей;
\item конфликтующее объединение патчей.
\end{itemize}

\begin{definition}[Неконфликтующее объединение]
  \emph{Неконфликтующее объединение} двух патчей~--- патч, обладающий
  эффектами обоих объединяемых патчей. При этом, объединяемые патчи не
  должны \emph{конфликтовать} друг с другом. Определение
  \emph{конфликтования} патчей будет дано позднее.
\end{definition}

Например, патчи <<добавить пустой файл \texttt{a.txt}>> и <<добавить
пустой файл \texttt{b.txt}>>~--- \emph{неконфликтующие} (при условии
отсутсвия до их применения обоих этих файлов.

\begin{definition}[Конфликтующее объединение]
  \emph{Конфликтующее объединение} двух патчей~--- патч, получающийся
  в результате последовательного применения сначала первого, а затем
  второго патчей. В данной работе будет рассматриваться конфликтующее
  объединение, при котором второй патч может менять \emph{только} то,
  что уже поменял первый.
\end{definition}

Для определения того, \emph{конфликтуют} ли два патча, введём понятие
\emph{формы} патча.

\begin{definition}[Форма патча]
  \emph{Форма} патча~--- нечто, что характеризует места ревизии, в
  которые патч вносит изменения. Для каждой системы контроля версий
  это будет что-то своё. Посмотрев на две формы, можно сказать, будут
  ли конфликтовать два обладающих ими патча.
\end{definition}

Будем решать поставленную задачу с использованием языка
программирования Agda. Было реализовано две системы контроля версий
для разных видов ревизий~(рисунок \ref{fig:repotypes}): 
\begin{itemize}
\item вектора фиксированной длины~(рисунок~\ref{fig:repotypes-vec});
\item двоичные деревья с элементами в
  вершинах~(рисунок~\ref{fig:repotypes-tree}).
\end{itemize}

Для этих систем контроля версий и операций над ними были доказаны
некоторые свойства.

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.45\textwidth}
    \centering
    \begin{tikzpicture}
      \matrix [draw=black] 
      {\vecd{a} & \vecd{b} & \vecd{c} & 
        \vecd{d} & \vecd{e} & \vecd{f} \\};
    \end{tikzpicture}
    \caption{Вектор константной длины}
    \label{fig:repotypes-vec}
  \end{subfigure}
  \begin{subfigure}[b]{0.45\textwidth}
    \centering
    \begin{tikzpicture}
      \node[treev] {a}
      child[treearr] {node[treev] {b}
        child[treearr] {node[treev] {c}
        }
        child[treearr] {node[treev] {d}
        }
      }
      child[treearr] {node[treev] {e}
      };
    \end{tikzpicture}
    \caption{Двоичное дерево с элементами в вершинах}
    \label{fig:repotypes-tree}
  \end{subfigure}
  \caption{Виды ревизий}
  \label{fig:repotypes}
\end{figure}

