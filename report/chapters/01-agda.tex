\section{Agda}

Agda~\cite{agda}~--- функциональный язык программирования с поддержкой
\emph{зависимых типов}. В силу \emph{изоморфизма Карри-Ховарда} в
применении к \emph{интуиционистской теории типов Мартина-Лёфа},
используется также как \emph{верификатор доказательств}~(proof
checker) и язык \emph{доказательного программирования}~(proof assistant).
% proof assistant и proof checker это разные вещи
% это изменение — мной изобретённая терминология
Разберём некоторые из этих терминов.

\subsection{Интуиционистская логика}

\emph{Интуиционистская}~(или \emph{конструктивная})
логика~\cite{шень2,curryhoward}~--- раздел математики, занимающийся
изучением \emph{конструктивных} логических объектов, то есть объектов,
для которых существует вычислимый алгоритм их конструирования.
% из заданного набора \emph{атомов} при помощи заданного набора
% примитивных \emph{логических операций}, где оба класса обладают
% свойством \emph{реализуемости}.

% Об этом ^^^ можно написать, но тогда придётся давать много
% определений (что такое реализаторы, Клини- и BHK-интерпретацию) и философии.

Интуиционистская логика отличается от \emph{классической} отсутствием
\emph{закона исключённого третьего}~($\forall A : A \vee \neg A$) или
эквивалентного ему \emph{закона снятия двойного отрицания}~($\forall A
: \neg (\neg A) \to A$). Это отличие даёт возможность оперирования
логическими выражениями также, как программами~\cite{mltt}.
% [ссылка на статью Говарда 69, На Мартина-Лёфа "Intuitionistic Type Theory" и "Constructive mathematics and computer programming"]
%% TODO Говарда 69 не нашёл

% это передвинуть до subsection{Интуиционистская теория типов Мартина-Лёфа}
% Curry-Howard более общ и ранше, чем Мартин-Лёф
\subsection{Изоморфизм Карри\,–\,Ховарда}

\emph{Изоморфизм Карри\,--\,Ховарда}~\cite{curryhoward} позволяет
установить взаимно-однозначное соответствие между логическими
системами и языками программирования. Одним из простых примеров
является изоморфизм между программами на языке \emph{простого
  типизированного $\lambda$-исчисления с суммами и
  произведениями}~\cite{curryhoward} и \emph{высказываниями в
  интуиционистской логике}~\cite{curryhoward}. Его можно увидеть в
таблице на рисунке~\ref{fig:curry-howard-int}. 

Чуть более сложным примером является изоморфизм между
\emph{исчислением высказываний}~\cite{шень2,curryhoward} и
\emph{теорией типов Мартина-Лёфа}. Именно на изоморфизме
Карри\,--\,Ховарда и основана концепция \emph{верификаторов
  доказательств} и \emph{автоматических доказывателей теорем}. Язык
программирования Agda также основан на этом принципе.

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.55\textwidth}
    \centering
    \begin{tabular}{|l|l|}
      \hline
      \textbf{Логика} & \textbf{Программирование} \\
      \hline
      Высказывание & Тип \\
      \hline
      Доказуемое высказывание & Населённый тип \\
      \hline
      Ложное высказывание & $\bot$ \\
      \hline
      $A \to B$ & Функция из $A$ в $B$ \\
      \hline
      $A \wedge B$ & $A \times B$ \\
      \hline
      $A \vee B$ & $A + B$ \\
      \hline
    \end{tabular}
    \caption{Исчисление высказываний и просто типизированное
      $\lambda$-исчисление}
    \label{fig:curry-howard-int}
  \end{subfigure}
  \begin{subfigure}[b]{0.4\textwidth}
    \centering
    \begin{tabular}{|l|l|}
      \hline
      \textbf{Логика} & \textbf{Программирование} \\
      \hline
      $\forall x : A(x)$ & $\Pi_{(x:\tau)} A(x)$ \\
      \hline
      $\exists x : A(x)$ & $\Sigma_{(x:\tau)} A(x)$\\
      \hline
    \end{tabular}
    \caption{Исчисление предикатов и теория типов Мартина-Лёфа}
    \label{fig:curry-howard-mltt}
  \end{subfigure}
  \caption{Изоморфизм Карри\,--\,Ховарда}
\end{figure}

\subsection{Интуиционистская теория типов Мартина-Лёфа}

\emph{Интуиционистская теория типов Мартина-Лёфа}~\cite{mltt}~---
теория типов, расширение простого типизированного
$\lambda$-исчисления. Основным отличием от него является добавление
$\Pi$- и $\Sigma$-типов.

\subsubsection{$\Pi$-типы}

$\Pi$-типы~(\emph{зависимые произведения}) $\Pi_{x:A} B(x)$ являются
обобщением типов-функций, у которых, правда, тип результата может
зависеть от \emph{значения} аргумента: тип функции $X \to Y$ можно
представить как $\Pi_{x:X} Y(x)$, где $x$~--- \emph{свежая}
переменная, не входящая свободно в $Y$. Например, тип функций
$\mathbb{Z} \to \mathbb{N}$ можно представить как $\Pi_{x:\mathbb{Z}}
\mathbb{N}$.

\subsubsection{$\Sigma$-типы}

$\Sigma$-типы~(\emph{зависимые суммы}) $\Sigma_{x:A} B(x)$ являются
обобщением пары, в которой второй аргумент может зависеть от первого.
Например, если $String(n)$~--- тип строк длины $n$, то
$\Sigma_{n:\mathbb{N}} String(n)$ будет парой из длины и строки такой
длины.

\subsubsection{$Id$-типы}

Пусть имеются две переменных одного и того же типа $a, b : A$. Введём
тип $a = b$, означающий \emph{равенство} $a$ и $b$. Экземпляр этого
типа будет являться доказательством того, что $a$ и $b$ равны.
Единственный конструктор типа $a = b$ будет говорить, что некоторое
значение равно самому себе: $\mathrm{refl} : \Pi_{x:A} x = x$.

\subsubsection{Рекурсивные типы данных}

В программировании очень часто используются рекурсивные типы данных:
натуральные числа, связные списки, деревья. Во всех этих типах есть
особенность, что при определении считается, что тип уже определён:
список это элемент и список, или ничего. Для упрощения теории,
запрещается непосредственно определять рекурсивные типы, однако вместо
этого даётся механизм, который всё-таки позволяет так делать:
$\mu$-типы или $W$-типы.

$\mu$-типы похожи на $\lambda$-абстракцию в $\lambda$-исчислении, но
над типами. Там также производится абстрагирование, именование
переменной и разрешение на дальнейшее её использование. Например, с
помощью $\mu$-типов список натуральных чисел можно определить
следующим образом: $\mathbb{N}List :\equiv \mu T. (\mathbb{N} \times
T) + \top$, где $\top$~--- одноэлементный тип~(Unit type).

$W$-типы работают следующим образом. На основе типа $A$ и конструктора
типа $B : A \to Set$ строится тип $W_{a : A} B(a)$. Тип $A$ отвечает
за некие <<метки>>, говорящие, как именно конструировать целевой
рекурсивный тип. Например, для списков $A$, так как у списка два
конструктора, будет иметь мощность два. $B(a)$ же, в некотором смысле,
описывает аргументы соответствующего $a$ конструктора. Таким образом,
$W$-типы позволяют получить рекурсивные типы, представленные
фундированными~(well-founded) деревьями.

\subsection{Типы данных в Agda}

% хоть с примером про List
\input{chapters/AgdaExample}

\subsection{Индексированные семейства}

\input{chapters/AgdaIndexed}

