\section{Agda}

Agda~\cite{agda}~--- функциональный язык программирования с поддержкой
\emph{зависимых типов}. В силу \emph{изоморфизма Карри-Ховарда} в
применении к \emph{интуиционистской теории типов Мартина-Лёфа},
используется также как \emph{верификатор доказательств}~(proof
checker) и язык \emph{доказательного программирования}~(proof assistant).
% proof assistant и proof checker это разные вещи
% это изменение — мной изобретённая терминология
Разберём некоторые из этих терминов.

\subsection{Интуиционистская логика}

\emph{Интуиционистская}~(или \emph{конструктивная})
логика~\cite{шень2,curryhoward}~--- раздел математики, занимающийся
изучением \emph{конструктивных} логических объектов, то есть объектов,
для которых существует вычислимый алгоритм их конструирования.
% из заданного набора \emph{атомов} при помощи заданного набора
% примитивных \emph{логических операций}, где оба класса обладают
% свойством \emph{реализуемости}.

% Об этом ^^^ можно написать, но тогда придётся давать много
% определений (что такое реализаторы, Клини- и BHK-интерпретацию) и философии.

Интуиционистская логика отличается от \emph{классической} отсутствием
\emph{закона исключённого третьего}~($\forall A : A \vee \neg A$) или
эквивалентного ему \emph{закона снятия двойного отрицания}~($\forall A
: \neg (\neg A) \to A$). Это отличие даёт возможность оперирования
логическими выражениями также, как программами. %[ссылка на статью Говарда 69, На Мартина-Лёфа "Intuitionistic Type Theory" и "Constructive mathematics and computer programming"]

\subsection{Интуиционистская теория типов Мартина-Лёфа}

\emph{Интуиционистская теория типов Мартина-Лёфа}~\cite{mltt}~---
теория типов, расширение простого типизированного
$\lambda$-исчисления. Основным отличием от него является добавление
$\Pi$- и $\Sigma$-типов.

\subsubsection{$\Pi$-типы}

$\Pi$-типы~(\emph{зависимые произведения}) $\Pi_{x:A} B(x)$ являются
обобщением типов-функций, у которых, правда, тип результата может
зависеть от \emph{значения} аргумента: тип функции $X \to Y$ можно
представить как $\Pi_{x:X} Y(x)$, где $x$~--- \emph{свежая}
переменная, не входящая свободно в $Y$. Например, тип функций
$\mathbb{Z} \to \mathbb{N}$ можно представить как $\Pi_{x:\mathbb{Z}}
\mathbb{N}$.

\subsubsection{$\Sigma$-типы}

$\Sigma$-типы~(\emph{зависимые суммы}) $\Sigma_{x:A} B(x)$ являются
обобщением пары, в которой второй аргумент может зависеть от первого.
Например, если $String(n)$~--- тип строк длины $n$, то
$\Sigma_{n:\mathbb{N}} String(n)$ будет парой из длины и строки такой
длины.

\subsection{$Id$-типы}

% надо

\subsection{Рекурсивные типы данных}

% не вдаваясь в подробности, просто, что есть μ и W.
% и что там много проблем которые нас не интересуют

\subsection{Типы данных в Agda}

% хоть с примером про List

\subsection{Индексированные семейства}

% Процитирую себя на эту же тему в работе Рыбака:
%
%> Суть в том, что
%> 
%> data Vec (A : Set) : ℕ → Set where
%>   []  : Vec A zero
%>   _∷_ : ∀ {n} → A → Vec A n → Vec A (succ n)
%> 
%> в метатеории где дататайпы бывают только без индексов представляется в
%> виде
%> 
%> data Vec (A : Set) (n : ℕ) : Set where
%>   []  : (n ≡ zero) → Vec A n
%>   _∷_ : ∀ {k} → (n ≡ succ k) → A → Vec A k → Vec A n
%> 
%> Агда явно, конечно, ничего такого не делает, она просто унифицирует
%> индексы в типах у того по чему идёт паттерн-матчинг с индексами всех
%> конструкторов и оставляет только те варианты, где удаётся
%> сунифицировать. При этом в каждом полученном варианте переменным,
%> указанным в индексах, присываиваются полученные унификацией значения
%> (синтаксически явно написанным из них соответствуют dotted
%> parameters). В BrutalDepTypes немного словообильнее об этом написано.
%
% тебе так подробно не надо, но идею семейств и этот пример с Vec надо
% бы изложить

% это нафиг, мы тут не foundational проблемы решаем

% это передвинуть до subsection{Интуиционистская теория типов Мартина-Лёфа}
% Curry-Howard более общ и ранше, чем Мартин-Лёф
\subsection{Изоморфизм Карри\,–\,Ховарда}

\emph{Изоморфизм Карри\,--\,Ховарда}~\cite{curryhoward} позволяет
установить взаимно-однозначное соответствие между логическими
системами и языками программирования. Одним из простых примеров
является изоморфизм между программами на языке \emph{простого
  типизированного $\lambda$-исчисления с суммами и
  произведениями}~\cite{curryhoward} и \emph{высказываниями в
  интуиционистской логике}~\cite{curryhoward}. Его можно увидеть в
таблице на рисунке~\ref{fig:curry-howard-int}. 

Чуть более сложным примером является изоморфизм между
\emph{исчислением высказываний}~\cite{шень2,curryhoward} и
\emph{теорией типов Мартина-Лёфа}. Именно на изоморфизме
Карри\,--\,Ховарда и основана концепция \emph{верификаторов
  доказательств} и \emph{автоматических доказывателей теорем}. Язык
программирования Agda также основан на этом принципе.

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.55\textwidth}
    \centering
    \begin{tabular}{|l|l|}
      \hline
      \textbf{Логика} & \textbf{Программирование} \\
      \hline
      Высказывание & Тип \\
      \hline
      Доказуемое высказывание & Населённый тип \\
      \hline
      Ложное высказывание & $\bot$ \\
      \hline
      $A \to B$ & Функция из $A$ в $B$ \\
      \hline
      $A \wedge B$ & $A \times B$ \\
      \hline
      $A \vee B$ & $A + B$ \\
      \hline
    \end{tabular}
    \caption{Исчисление высказываний и просто типизированное
      $\lambda$-исчисление}
    \label{fig:curry-howard-int}
  \end{subfigure}
  \begin{subfigure}[b]{0.4\textwidth}
    \centering
    \begin{tabular}{|l|l|}
      \hline
      \textbf{Логика} & \textbf{Программирование} \\
      \hline
      $\forall x : A(x)$ & $\Pi_{(x:\tau)} A(x)$ \\
      \hline
      $\exists x : A(x)$ & $\Sigma_{(x:\tau)} A(x)$\\
      \hline
    \end{tabular}
    \caption{Исчисление предикатов и теория типов Мартина-Лёфа}
    \label{fig:curry-howard-mltt}
  \end{subfigure}
  \caption{Изоморфизм Карри\,--\,Ховарда}
\end{figure}
