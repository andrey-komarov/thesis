\section{Git}

Git~--- одна из наиболее распространённых на данный момент
распределённых систем контроля версий. Каждый разработчик хранит у
себя все изменения, вносимые в репозиторий. Репозитории разных
разработчиков могут свободно обмениваться между собой патчами
независимо от какого-либо единственного выделенного сервера,
поддерживая проект в актуальном состоянии.

\subsection{Внутренние структуры Git}
\label{sec:git-internals}

Внутри репозитория Git хранит \emph{объекты} и \emph{ссылки}.
\emph{Объектом} называются произвольные данные в паре с их 160-битным
SHA-1-хешом. Git хранит отображение SHA-1-хеша в объект, который имеет
заданный хеш. \emph{Ссылкой} на объект называют значение его
SHA-1-хеша. SHA-1-хеша какого-то из имеющихся объектов. Поверх этой
простой структуры сделано всё остальное~--- файлы, ветки, патчи,
коммиты, итд.

У каждого хранимого Git-ом объекта есть свой тип, который определяет,
для какой цели предназначен этот объект. Git использует следующие типы
для объектов: blob, tree, commit, tag.

% TODO картинку для каждого типа?

\subsubsection{blob}

\emph{Blob}~--- самый простой объект. Он просто хранит произвольные
данные и может использоваться, например, для хранения,
непосредственно, файлов, находящихся под контролем версий.

\subsubsection{tree}

Объекты типа \emph{tree} используются для хранения содержимого
директории. В объекте этого типа хранится список ссылок на другие
объекты. Объекты, на которые ссылаются, могут иметь тип tree или blob.
С помощью ссылок на объекты типа tree достигается возможность хранения
директорий в древообразном формате, а не только в корне.

\subsubsection{commit}

В объектах типа commit хранится следующее:

\begin{itemize}
\item информация об авторе коммита: имя, почтовый адрес и время
  совершения;
\item ссылка на объект типа tree, соответствующий состоянию рабочей
  директории на момент совершения коммита;
\item ссылки на \emph{родителей} этого коммита. В случае, если это был
  \emph{merge-коммит}, родителей может быть несколько.
\end{itemize}

\subsubsection{tag}

Tag хранит внутри ссылку на какой-то объект, а также, описание того,
кто создал этот тег. Это может использоваться, например, для того,
чтобы можно было быстро восстановить рабочую директорию на какой-то
опеределённый момент времени, не зная её хеш, а зная лишь имя тега.

\subsubsection{Оптимизация хранения объектов}

Из описания выше можно понять, что для поддержания корректной
репозитория требуется иметь в хранилище объектов все версии всех
файлов. Однако, это, очевидно, невыгодно и будет занимать слишком
много места на диске. Для оптимизации дискового пространства в Git
применяется две оптимизации. 

Во-первых, время от времени, происходит сжатие архивация и сжатие
объектов в один файл. Это позволяет более эффективно использовать
дисковое пространство так как, во-первых, сжатые данные обычно
занимают меньше места, а, во-вторых, нет накладных расходов файловой
системы на хранение большого числа маленьких файлов.

Вторая, более существенная оптимизация заключается в том, что все
версии одного и того же файла не хранятся отдельно. Вместо этого,
хранится только \emph{последняя} версия этого файла, а также, для
каждой из предыдущих хранится разница (diff, delta, дельта) со
следующей за ней. Было решено хранить \emph{последнюю} версию файла
вместо \emph{первой} потому, что обращения к последней версии файла
обычно происходит чаще, чем к первой, а в случае хранения первой, были
бы большие накладные расходы на расчёт последней: для этого бы
потребовалось применить последовательно все разницы для этого файла.

\subsection{Внешние структуры Git (TODO: Очень плохое название)}

В разделе~\ref{sec:git-internals} было дано описание внутренних
структур системы контроля версий Git. Однако, пользователю практически
никогда не нужно ни знать ни их устройство, ни то, как ими
манипулировать. Пользователю предоставляется более высокоуровневый
интерфейс управления. 

Большую часть времени, пользователь \emph{репозитория} будет работать
с \emph{коммитами} и \emph{ветками}.

\begin{definition}[Коммит]
  Назовём \emph{коммитом} запомненное в репозитории состояние рабочей
  копии (файлов и их содержимого) в какой-либо момент времени.
\end{definition}

\begin{definition}[Git-репозиторий]
  \emph{Git-репозиторий}~--- ориентированный ациклический граф
  коммитов, в котором, для удобства, в некоторых вершинах стоят метки,
  называемые ветками.
  
  Вершины этого графа~--- коммиты, состояния, в которых когда-либо
  находился этот репозиторий. Рёбра~--- патчи, то, как из
  состояния-начала ребра получилось состояние-конец.
\end{definition}

\begin{definition}[Ветка]
  \emph{Ветка}~--- именованная метка в одной из вершин графа коммитов
  в репозитории.
\end{definition}

Также, в репозитории есть отдельная сущность~--- HEAD. 

\begin{definition}[HEAD]
  \emph{HEAD}~--- указатель на последний сделанный коммит.
\end{definition}

HEAD используется для того, чтобы Git знал, какие рёбра добавлять к
новой созданной вершине при коммите, а также, чтобы знать, с рабочей
директорией, соответствующей какому коммиту, следует сравнивать
текущую изменённую пользователем рабочую директорию. 

Рассмотрим пример работы с Git-репозиторием, изображённый на
рисунке~\ref{fig:git-workflow}, поясняющий эту концепцию. Рассмотрим
происходящее на ней по шагам.

\begin{enumerate}
\item Создание нового пустого репозитория~(рис.~\ref{fig:git-init}).
  После этого есть один коммит $A$ и одна ветка master, которая
  указывает на этот коммит. HEAD указывает на master.
\item Добавление файла ``a.txt'' под контроль
  версий~(рис.~\ref{fig:git-add-commit}). После этого добавляется
  новый коммит $B$, в котором есть добавленный файл. Указатель ветки
  master смещается на $B$, HEAD указывает на master.
\item Создание новой ветки feature и переключение на
  неё~(рис.~\ref{fig:git-checkout-feature}). Создаётся ветка,
  являющаяся копией текущей. HEAD указывал на $B$, поэтому,
  вновьсозданная ветка будет указывать туда же. HEAD указывает на
  feature.
\item Добавление нового файла ``b.txt'' под контроль
  версий~(рис.~\ref{fig:git-add-commit-b}). Создаётся новый коммит
  $C$, содержащий оба файла, а также, ветка feature перемещается в
  $C$. HEAD указывает на feature.
\item Переключение на ветку master и добавление файла ``c.txt'' под
  контроль версий~(рис.~\ref{fig:git-checkout-master}). Создаётся
  новый коммит $D$ на основе $B$, содержащий ``c.txt''. Ветка master
  перемещается в $D$. HEAD указывает на master.
\item Объединение веток feature и master~(рис.~\ref{fig:git-merge}).
  Создаётся новый коммит $E$ на основе $C$ и $D$, содержащий изменения
  из обоих. Ветка master перемещается в $E$. HEAD указывает на master.
\end{enumerate}

\begin{figure}
  \centering
  \begin{subfigure}{0.3\textwidth}
    \centering
    \begin{tikzpicture}[>=stealth,thick]
      \node[gitcommit] (a) {$A$\nodepart{second}};
      \node[gitbranch] (master) [above=of a] {master};

      \draw[gitbranchconnect] (master) to (a);
    \end{tikzpicture}
    \caption{init}
    \label{fig:git-init}
  \end{subfigure}
  \begin{subfigure}{0.3\textwidth}
    \centering
    \begin{tikzpicture}[>=stealth,thick]
      \node[gitcommit] (a) {$A$\nodepart{second}};
      \node[gitcommit] (b) [right=of a] {$B$\nodepart{second}a.txt};
      \node[gitbranch] (master) [above=of b] {master};

      \draw[<-] (a) to (b);
      \draw[gitbranchconnect] (master) to (b);
    \end{tikzpicture}
    \caption{add a.txt; commit a.txt}
    \label{fig:git-add-commit}
  \end{subfigure}
  \begin{subfigure}{0.3\textwidth}
    \centering
    \begin{tikzpicture}[>=stealth,thick]
      \node[gitcommit] (a) {$A$\nodepart{second}};
      \node[gitcommit] (b) [right=of a] {$B$\nodepart{second}a.txt};
      \node[gitbranch] (master) [above=of b] {master};
      \node[gitbranch] (feature) [below=of b] {feature};

      \draw[<-] (a) to (b);
      \draw[gitbranchconnect] (master) to (b);
      \draw[gitbranchconnect] (feature) to (b);
    \end{tikzpicture}
    \caption{checkout -b feature}
    \label{fig:git-checkout-feature}
  \end{subfigure}
  \begin{subfigure}{0.45\textwidth}
    \centering
    \begin{tikzpicture}[>=stealth,thick]
      \node[gitcommit] (a) {$A$\nodepart{second}};
      \node[gitcommit] (b) [right=of a] {$B$\nodepart{second}a.txt};
      \node[gitcommit] (c) [below right=of b]
      {$C$\nodepart{second}a.txt, b.txt};
      \node[gitbranch] (master) [above=of b] {master};
      \node[gitbranch] (feature) [below=of c] {feature};

      \draw[<-] (a) to (b);
      \draw[<-] (b) to (c);
      \draw[gitbranchconnect] (master) to (b);
      \draw[gitbranchconnect] (feature) to (c);
    \end{tikzpicture}
    \caption{add b.txt; commit b.txt}
    \label{fig:git-add-commit-b}
  \end{subfigure}
  \begin{subfigure}{0.45\textwidth}
    \centering
    \begin{tikzpicture}[>=stealth,thick]
      \node[gitcommit] (a) {$A$\nodepart{second}};
      \node[gitcommit] (b) [right=of a] {$B$\nodepart{second}a.txt};
      \node[gitcommit] (c) [below right=of b]
      {$C$\nodepart{second}a.txt, b.txt};
      \node[gitcommit] (d) [right=of b]
      {$D$\nodepart{second}a.txt, c.txt};
      \node[gitbranch] (master) [above=of d] {master};
      \node[gitbranch] (feature) [below=of c] {feature};

      \draw[<-] (a) to (b);
      \draw[<-] (b) to (c);
      \draw[<-] (b) to (d);
      \draw[gitbranchconnect] (master) to (d);
      \draw[gitbranchconnect] (feature) to (c);
    \end{tikzpicture}
    \caption{checkout master; add c.txt; commit c.txt}
    \label{fig:git-checkout-master}
  \end{subfigure}
  \begin{subfigure}{\textwidth}
    \centering
    \begin{tikzpicture}[>=stealth,thick]
      \node[gitcommit] (a) {$A$\nodepart{second}};
      \node[gitcommit] (b) [right=of a] {$B$\nodepart{second}a.txt};
      \node[gitcommit] (c) [below right=of b]
      {$C$\nodepart{second}a.txt, b.txt};
      \node[gitcommit] (d) [right=of b]
      {$D$\nodepart{second}a.txt, c.txt};
      \node[gitcommit] (e) [right=of d]
      {$E$\nodepart{second}a.txt, b.txt, c.txt};
      \node[gitbranch] (master) [above=of e] {master};
      \node[gitbranch] (feature) [below=of c] {feature};

      \draw[<-] (a) to (b);
      \draw[<-] (b) to (c);
      \draw[<-] (b) to (d);
      \draw[<-] (c) to (e);
      \draw[<-] (d) to (e);
      \draw[gitbranchconnect] (master) to (e);
      \draw[gitbranchconnect] (feature) to (c);
    \end{tikzpicture}
    \caption{merge feature}
    \label{fig:git-merge}
  \end{subfigure}
  \caption{Пример работы в Git-репозитории}
  \label{fig:git-workflow}
\end{figure}

Как можно видеть из этого описания, большинство операций над
репозиторием можно выразить в виде несложных модификаций низлежащего
графа. Рассмотрим некоторые из этих действий более подробно.

\subsubsection{Создание репозитория}

Существуют два способа создания репозитория.

\begin{enumerate}
\item Создание пустого репозитория. Выполняется командой git init.
  Действие этой команды было продемонстрировано на
  рисунке~\ref{fig:git-init}.
\item Клонирование имеющегося удалённого репозитория. Выполняется
  командой git init. Получившийся репозиторий содержит почти всё, что
  было в клонируемом. В частности, копируются все прошлые версии
  файлов.
\end{enumerate}

